
rm(list=ls())
library('mgcv'); library("tidyverse")

library("survival");library("ggplot2"); library("cubature");library("tidyverse");library("gridExtra")
# set the seed
set.seed(102131)

########################
##                    ##
##  Helper functions  ##
##                    ##
########################

## function for simulating survival times with Weibull baseline hazard
# eta: vector containing the log hazard (linear predictor) for each subject
# lambda: scale parameter for the baseline hazard
# p: shape paramter for the baseline hazard
# gen_Ct: function for generating censoring times, default is exponential with mean 5 truncated at t=1
gen_St <- function(eta, lambda, p, gen_Ct = function(N) pmin(1,rexp(N, 1/5)) ){
  N <- length(eta)
  U <- runif(N, 0, 1)
  St = (-log(U)/(lambda*exp(eta)))^(1/p)
  Ct = gen_Ct(N)
  
  data.frame("event" = as.numeric(St<=Ct), "time" = pmin(St,Ct), "eta" = eta)
}
ID_AUC <- function(marker, Stime, status, predict.time, entry = NULL, ...){
  
  if (length(entry) == 0) {
    
    entry = rep(0, NROW(Stime))
    
  }
  
  at.risk <- ((Stime >= predict.time) & (entry <= predict.time))
  
  eta     <- marker[at.risk]
  
  status2 <- status
  
  status2[Stime > predict.time] <- 0
  
  status2 <- status2[at.risk]
  
  
  
  C_num <- 0
  
  n_case_t    <- sum(status2)
  
  n_control_t <- sum(1-status2)
  
  inx_ti <- which(status2 == 1)
  
  inx_tj <- which(status2 == 0)
  
  for(id in inx_ti){
    
    C_num <- C_num + sum(eta[id] > eta[inx_tj]) + 0.5*sum(eta[id] == eta[inx_tj])
    
  }
  
  out <- C_num/(n_case_t*n_control_t)
  
  
  
  out    
  
}
####################################################################################
##                                                                                ##
##  Simulating Data for Large Sample Validation of Theoretical I/D AUC estimates  ##
##                                                                                ##
####################################################################################


## We simulate data generated by a "true" underlying  Cox model of the form: log \lambda_i(t|.) = log \lambda_0(t) + \eta_i
##    Model: the true model using 3 predictors: \eta_i1 = X_i1*\beta_1 +  X_i2*\beta_2 +  X_i3*\beta_3
## True beta vector
Beta <- c(1,-1,0.25)

## number of individuals to sample
N_samp <- 500



# number of subjects in data
N <- nrow(df)
# number of bootstrap samples to take
nboot <- 1000
results_ls <- vector(mode="list",length=nboot)
pb <- txtProgressBar(min=0,max=nboot,style=3)
for(i in 1:nboot){
  ### Simulate data
  ## simulate data that are used to obtain true log hazard for each subject
  X_i  <- matrix(rnorm(N_samp*3), ncol=3, nrow=N_samp)
  ## obtain true linear predictor (less log hazard) for each subject
  eta_i <- X_i %*% Beta
  ## simulate survival times/event indicators for each subject in the data
  ## here we set censoring time to infinity -- this gives us a sense of the true distribution of survival times
  df_i <- gen_St(eta=eta_i,lambda=2, p=2, gen_Ct = function(N) rep(1,N))
  
  ## calculate empirical AUC
  ut_i <- unique(df_i$time[df_i$event==1])
  ut_vec_i <- rep(NA, length(ut_i))
  for(t_i in seq_along(ut_i)){
    ut_vec_i[t_i] <- ID_AUC(df_i$eta, Stime=df_i$time, status=df_i$event, predict.time=ut_i[t_i])
  }
  results_ls[[i]] <- data.frame("time"=ut_i,"AUC"=ut_vec_i)
  ## store empirical AUC
  setTxtProgressBar(pb, i)
}

library('ggplot2')
results_df <- bind_rows(results_ls)


results_df %>% 
  ggplot(aes(x=time,y=AUC),alpha=0.1) + 
  geom_point() + 
  geom_smooth(method="gam",formula=y~s(x,bs="cr",k=20))

var_df <- 
  results_df %>% 
  mutate(time_bin = cut(time, breaks=seq(0,1,len=50),labels=seq(0,1,len=49)),
         time_bin = as.numeric(time_bin)) %>% 
  group_by(time_bin) %>% 
  summarize(var_AUC_hat = var(AUC))
var_df %>% 
  ggplot(aes(x=time_bin, y=var_AUC_hat)) + 
  geom_smooth(method="gam",formula=y~s(x,bs="cr"))

nboot <- 500
n_pred <- 100
tind_pred <- seq(0,1,len=n_pred)
arr_results <- array(NA, dim=c(nboot, 2, n_pred), 
                     dimnames=list("simulation"=1:nboot,
                                   "model"=c("traditional","IVW"),
                                   "time"=tind_pred))
for(i in 1:nboot){
  ### Simulate data
  ## simulate data that are used to obtain true log hazard for each subject
  X_i  <- matrix(rnorm(N_samp*3), ncol=3, nrow=N_samp)
  ## obtain true linear predictor (less log hazard) for each subject
  eta_i <- X_i %*% Beta
  ## simulate survival times/event indicators for each subject in the data
  ## here we set censoring time to infinity -- this gives us a sense of the true distribution of survival times
  df_i <- gen_St(eta=eta_i,lambda=2, p=2, gen_Ct = function(N) rep(1,N))
  
  ## calculate empirical AUC
  ut_i <- unique(df_i$time[df_i$event==1])
  ut_vec_i <- rep(NA, length(ut_i))
  for(t_i in seq_along(ut_i)){
    ut_vec_i[t_i] <- ID_AUC(df_i$eta, Stime=df_i$time, status=df_i$event, predict.time=ut_i[t_i])
  }
  df_fit_gam <- data.frame("time"=ut_i,"AUC"=ut_vec_i)
  
  df_fit_gam <- data.frame("time"=ut_i,"AUC"=ut_vec_i)
  df_fit_gam <- 
    df_fit_gam %>% 
    mutate(time_bin = cut(time, breaks=seq(0,1,len=50),labels=seq(0,1,len=49)),
           time_bin = as.numeric(time_bin)) %>% 
    left_join(var_df, by="time_bin")
  
  fit_1 <- gam(AUC ~ s(time, bs="cr",k=20), method="REML", data=df_fit_gam)
  fit_2 <- gam(AUC ~ s(time, bs="cr",k=20), method="REML", data=df_fit_gam, weights=1/df_fit_gam$var_AUC_hat)
  
  df_pred <- data.frame("time"= seq(0,1,len=100))
  pred_1 <- predict(fit_1, newdata=df_pred,type='response')
  pred_2 <- predict(fit_2, newdata=df_pred,type='response')
  
  arr_results[i,1,] <- pred_1
  arr_results[i,2,] <- pred_2
    
  # par(mfrow=c(1,1))
  # plot(df_pred$time,pred_1,type='l')
  # lines(df_pred$time,pred_2,lty=2,col='red')
  
  ## store empirical AUC
  setTxtProgressBar(pb, i)
}

df_results <- as.data.frame.table(arr_results, stringsAsFactors = FALSE)

df_results %>% 
  mutate(time_fac = factor(time)) %>% 
  group_by(model,time_fac) %>% 
  summarize(AUC_mn = mean(Freq),
            time=time[1]) %>% 
  ungroup() %>% 
  mutate(time = as.numeric(time)) %>% 
  ggplot(aes(x=time, y=AUC_mn,color=model)) + 
  geom_line()
  

fit_1 <- gam(AUC ~ s(time, bs="cr",k=20), method="REML", data=df_fit_gam)
fit_2 <- gam(AUC ~ s(time, bs="cr",k=20), method="REML", data=df_fit_gam, weights=1/df_fit_gam$var_AUC_hat)
fit_3 <- gam(AUC ~ s(time, bs="cr",k=20), method="REML", data=df_fit_gam, family=betar())

pred_2 <- predict(fit_2, newdata=df_pred,type='response')
pred_3 <- predict(fit_3, newdata=df_pred,type='response')

plot(tind_pred, pred_2,ylim=c(0.5,1))
lines(tind_pred, pred_3,col='red',lty=2)



