## clear the working directory
rm(list=ls())
## load packages
# survival: fitting Cox regressions
# ggplot2: plotting results
# cubature: numeric integration
# tidyverse: data manipulation
library("survival");library("ggplot2"); library("cubature");library("tidyverse")
# set the seed
set.seed(102131)

########################
##                    ##
##  Helper functions  ##
##                    ##
########################

## function for simulating survival times with Weibull baseline hazard
# eta: vector containing the log hazard (linear predictor) for each subject
# lambda: scale parameter for the baseline hazard
# p: shape paramter for the baseline hazard
# gen_Ct: function for generating censoring times, default is exponential with mean 5 truncated at t=1
gen_St <- function(eta, lambda, p, gen_Ct = function(N) pmin(1,rexp(N, 1/5)) ){
    N <- length(eta)
    U <- runif(N, 0, 1)
    St = (-log(U)/(lambda*exp(eta)))^(1/p)
    Ct = gen_Ct(N)
    
    data.frame("event" = as.numeric(St<=Ct), "time" = pmin(St,Ct), "eta" = eta)
}

### Integration functions
### Note that we need two different functions since there is a double integral in the specificity formula
## function for integrating incident sensitivity
my_fn_sens <- function(x, t, lambda=1, p=1, mn_eta=0, sigma_eta=2){
    lambda*p*t^(p-1)*exp(x[1])*exp(-lambda*t^p*exp(x[1]))*dnorm(x[1], mean=mn_eta, sd=sigma_eta)
}
## function for integrating dynamic specificity
my_fn_spec <- function(x, lambda=1, p=1, mn_eta=0, sigma_eta=2){
    lambda*p*x[2]^(p-1)*exp(x[1])*exp(-lambda*x[2]^p*exp(x[1]))*dnorm(x[1], mean=mn_eta, sd=sigma_eta)
}





####################################################################################
##                                                                                ##
##  Simulating Data for Large Sample Validation of Theoretical I/D AUC estimates  ##
##                                                                                ##
####################################################################################


## We simulate data generated by a "true" underlying  Cox model of the form: log \lambda_i(t|.) = log \lambda_0(t) + \eta_i
##    Model: the true model using 3 predictors: \eta_i1 = X_i1*\beta_1 +  X_i2*\beta_2 +  X_i3*\beta_3
## True beta vector
Beta <- c(1,-1,0.25)
## we assume X_ip independent standard normal (i.e.  X_ip ~ N(0, 1) for p = 1,2,3)
## so then \eta_i ~ N(0, \sigma_\eta^2 = (1^2 + 1^2 + 0.25^2))
## That is, the linear predictor is normally distributed with mean zero and variance 3



## Simulate the data
## Number of subjects used to fit the model -- use a very large number so we can validate our theoretical results
N_obs  <- 10000000
## simulate data that are used to obtain true log hazard for each subject
X  <- matrix(rnorm(N_obs*3), ncol=3, nrow=N_obs)
## obtain true linear predictor (less log hazard) for each subject
eta <- X %*% Beta
## simulate survival times/event indicators for each subject in the data
data <- gen_St(eta=eta,lambda=2, p=2, gen_Ct = function(N) rep(1,N))

## set up an empty container for holding the results
## ? define tind, etaind, nt_pred and neta_pred
tind <- seq(0, 1, length.out = 100)
etaind <- seq(-7, 7, length.out = 100)
nt_pred <- length(tind)
neta_pred <- length(etaind)
sens_spec_mat <- array(NA, dim=c(2,2,nt_pred, neta_pred),
                  dimnames=list("estimand" = c("sensitivity","specificity"),
                                "estimator" = c("theoretical","empirical"),
                                "time" = tind, 
                                "eta" = etaind))
inx <- 1
delta_t <- 0.001
pb <- txtProgressBar(min=0, max=nt_pred*neta_pred,style=3)
for(i in seq_along(tind)){
    t_i <- tind[i]
    data_i_sens <- subset(data, (time >= t_i) & (time <= (t_i + delta_t)) & (event == 1))
    data_i_spec <- subset(data, (time >= t_i))
    for(j in seq_along(etaind)){
        eta_ij <- etaind[j]
        
        sens_spec_mat[1,1,i,j] <- adaptIntegrate(my_fn_sens, t=t_i, lowerLimit=c(eta_ij), upperLimit=c(500), lambda=2, p=2, sigma_eta=sqrt(sum(Beta^2)))$integral/
                                    adaptIntegrate(my_fn_sens, t=t_i, lowerLimit=c(-Inf), upperLimit=c(500), lambda=2, p=2, sigma_eta=sqrt(sum(Beta^2)))$integral
        sens_spec_mat[1,2,i,j] <- mean(data_i_sens$eta > eta_ij)
        
        sens_spec_mat[2,1,i,j] <- adaptIntegrate(my_fn_spec, lowerLimit=c(-Inf, t_i), upperLimit=c(eta_ij, Inf), lambda=2, p=2, sigma_eta =  sqrt(sum(Beta^2)))$integral/
                                    adaptIntegrate(my_fn_spec, lowerLimit=c(-Inf, t_i), upperLimit=c(Inf, Inf), lambda=2, p=2, sigma_eta =  sqrt(sum(Beta^2)))$integral
        sens_spec_mat[2,2,i,j] <- mean(data_i_spec$eta <= eta_ij)
        setTxtProgressBar(pb, value=inx)
        inx <- inx+1
    }
}
## convert the array of results to a data frame
df_plt <- as.data.frame.table(sens_spec_mat, responseName="y",stringsAsFactors = F)


## plot a few empirical and theoretical sensitivity and specificities to show we are getting reasonable results
## you'll note that the theoretical sensitivity tends to be a bit higher for a fixed cutoff threshold of the biomarker
## this is likely beacuse our "approximation" relies on us using a small window in the future and AUC is decreasing over time
## As a result, we expect theoretical AUC to be slightly higher
df_plt %>% 
    filter(time %in% tind[c(10,20,50,75)]) %>% 
    mutate(time = as.numeric(time), eta=as.numeric(eta)) %>% 
    ggplot() + 
    geom_point(aes(x=eta, y=y, color=estimator), alpha=0.5) + 
    facet_grid(estimand~time) + theme_bw()


### Calculate AUC for both theoretical and empirical results
## calculate AUC by integrating the ROC curve 
trap_integrate_ROC <- function(eta, sens, spec){
    if(!Inf %in% eta){
        sens <- c(sens, 0)
        spec <- c(spec, 1)
    }
    if(!c(-Inf) %in% eta){
        sens <- c(1, sens)
        spec <- c(0, spec)
    }
    x <- rev(1-spec)
    y <- rev(sens)
    n <- length(y)
    sum( (x[2:n] - x[1:(n-1)] ) * (y[1:(n-1)] + y[2:n]) )/2
}
df_AUC <- 
    df_plt %>% 
    pivot_wider(names_from="estimand", values_from="y") %>% 
    group_by(estimator, time) %>% 
    summarize(ID_AUC = trap_integrate_ROC(eta, sensitivity, specificity))

df_AUC %>% 
    mutate(time = as.numeric(time)) %>% 
    ggplot() + 
    geom_point(aes(x=time, y=ID_AUC, color=estimator)) + 
    scale_x_continuous(minor_breaks=seq(0,1,by=0.025)) + theme_bw() + 
    ylim(0.5,1) + ylab("I/D AUC")



## plot the ROC curve for theoretical and empirical sensitivity/specificity for a fixed time point
df_plt %>% 
    filter(time %in% time[40]) %>% 
    pivot_wider(names_from="estimand", values_from="y") %>% 
    mutate(FPR = 1-specificity) %>% 
    ggplot(aes(x=FPR, y=sensitivity, color=estimator)) + 
    geom_point() + theme_classic()
